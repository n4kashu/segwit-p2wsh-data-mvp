import React, { useCallback, useEffect, useMemo, useState } from "react";
// MVP: Store arbitrary bytes in a SegWit v0 P2WSH witnessScript, fund on testnet, then spend to reveal the bytes.
// Wallet: UniSat browser extension (https://docs.unisat.io/dev/open-api-documentation/unisat-wallet)
// Libraries: bitcoinjs-lib (PSBT + scripts). Tailwind for styling.

// --- deps ---
import * as bitcoin from "bitcoinjs-lib";
import { Buffer } from "buffer";

// ---- helpers ----
const TESTNET = bitcoin.networks.testnet;

function hexToBytes(hex: string): Uint8Array {
  const clean = hex.trim().replace(/^0x/, "");
  if (clean.length % 2 !== 0) throw new Error("Hex length must be even");
  const out = new Uint8Array(clean.length / 2);
  for (let i = 0; i < out.length; i++) {
    out[i] = parseInt(clean.substr(i * 2, 2), 16);
  }
  return out;
}

function utf8ToBytes(txt: string): Uint8Array {
  return new TextEncoder().encode(txt);
}

function encodeCompactSize(n: number): Buffer {
  if (n < 0xfd) return Buffer.from([n]);
  if (n <= 0xffff) {
    const b = Buffer.alloc(3);
    b[0] = 0xfd;
    b.writeUInt16LE(n, 1);
    return b;
  }
  if (n <= 0xffffffff) {
    const b = Buffer.alloc(5);
    b[0] = 0xfe;
    b.writeUInt32LE(n, 1);
    return b;
  }
  // JS number limit makes > 0xffffffff impractical here
  throw new Error("compactSize too large");
}

function witnessStackToScriptWitness(stack: Buffer[]): Buffer {
  // Serialize witness: varint count + for each: varint len + bytes
  const parts: Buffer[] = [encodeCompactSize(stack.length)];
  for (const item of stack) {
    parts.push(encodeCompactSize(item.length));
    parts.push(item);
  }
  return Buffer.concat(parts);
}

function buildEnvelopeScript(dataBytes: Uint8Array): Buffer {
  // Envelope: OP_FALSE OP_IF <data...> OP_ENDIF OP_TRUE
  return bitcoin.script.compile([
    bitcoin.opcodes.OP_FALSE,
    bitcoin.opcodes.OP_IF,
    Buffer.from(dataBytes),
    bitcoin.opcodes.OP_ENDIF,
    bitcoin.opcodes.OP_TRUE,
  ]);
}

function bytesToHex(u8: Uint8Array): string {
  return Array.from(u8)
    .map((b) => b.toString(16).padStart(2, "0"))
    .join("");
}

// --- UI ---
export default function App() {
  const [connected, setConnected] = useState(false);
  const [address, setAddress] = useState<string>("");
  const [networkName, setNetworkName] = useState<string>("");

  // data entry
  const [mode, setMode] = useState<"utf8" | "hex">("utf8");
  const [dataInput, setDataInput] = useState<string>("Hello from P2WSH!");

  // witness script + p2wsh address
  const [wscriptHex, setWscriptHex] = useState<string>("");
  const [p2wshAddress, setP2wshAddress] = useState<string>("");
  const [p2wshScriptPubKeyHex, setP2wshScriptPubKeyHex] = useState<string>("");
  const [wscriptLen, setWscriptLen] = useState<number>(0);

  // Step 1 (funding)
  const [fundAmount, setFundAmount] = useState<number>(1500); // sats (>=330 recommended for P2WSH dust)
  const [feeRateFund, setFeeRateFund] = useState<number>(2); // sats/vB
  const [fundingTxid, setFundingTxid] = useState<string>("");

  // Step 2 (spend)
  const [fundingVout, setFundingVout] = useState<number | "">("");
  const [fundingValue, setFundingValue] = useState<number | "">("");
  const [recipient, setRecipient] = useState<string>("");
  const [sendFee, setSendFee] = useState<number>(900); // sats, very rough for testnet
  const [spendTxid, setSpendTxid] = useState<string>("");
  const [building, setBuilding] = useState(false);
  const [broadcasting, setBroadcasting] = useState(false);
  const [message, setMessage] = useState<string>("");

  // Compute witnessScript & address when data changes
  useEffect(() => {
    try {
      const bytes = mode === "utf8" ? utf8ToBytes(dataInput) : hexToBytes(dataInput);
      const wscript = buildEnvelopeScript(bytes);
      setWscriptHex(wscript.toString("hex"));
      setWscriptLen(wscript.length);
      const p2wsh = bitcoin.payments.p2wsh({ redeem: { output: wscript }, network: TESTNET });
      setP2wshAddress(p2wsh.address || "");
      setP2wshScriptPubKeyHex((p2wsh.output || Buffer.alloc(0)).toString("hex"));
    } catch (e: any) {
      setWscriptHex("");
      setP2wshAddress("");
      setP2wshScriptPubKeyHex("");
    }
  }, [mode, dataInput]);

  const connect = useCallback(async () => {
    try {
      // @ts-ignore
      const unisat = (window as any).unisat;
      if (!unisat) throw new Error("UniSat extension not found");
      await unisat.requestAccounts();
      await unisat.switchChain("BITCOIN_TESTNET");
      const net = await unisat.getNetwork();
      setNetworkName(net);
      const accounts: string[] = await unisat.getAccounts();
      setAddress(accounts[0]);
      setConnected(true);
      setMessage("Connected to UniSat on testnet.");
    } catch (e: any) {
      setMessage(e?.message || String(e));
    }
  }, []);

  const fundP2WSH = useCallback(async () => {
    try {
      setMessage("");
      if (!p2wshAddress) throw new Error("P2WSH address not ready");
      if (wscriptLen === 0) throw new Error("Witness script empty");
      if (wscriptLen > 3600) throw new Error("Script > 3600 bytes — likely nonstandard for relay. Reduce data.");
      if ((fundAmount || 0) < 400) throw new Error("Fund amount too low; use at least ~400 sats for P2WSH");
      // @ts-ignore
      const unisat = (window as any).unisat;
      const txid = await unisat.sendBitcoin(p2wshAddress, Number(fundAmount), { feeRate: Number(feeRateFund) });
      setFundingTxid(txid);
      setMessage("Funding sent. Paste vout or use auto-detect.");
    } catch (e: any) {
      setMessage(e?.message || String(e));
    }
  }, [p2wshAddress, wscriptLen, fundAmount, feeRateFund]);

  const autodetectVout = useCallback(async () => {
    try {
      if (!fundingTxid || !p2wshAddress) throw new Error("Need funding txid and P2WSH address");
      const res = await fetch(`https://mempool.space/testnet/api/tx/${fundingTxid}`);
      if (!res.ok) throw new Error("Failed to fetch tx from mempool.space");
      const tx = await res.json();
      const idx = tx.vout.findIndex((o: any) => o.scriptpubkey_address === p2wshAddress);
      if (idx < 0) throw new Error("Could not find P2WSH output in that tx");
      setFundingVout(idx);
      setFundingValue(tx.vout[idx].value);
      setMessage(`Detected vout=${idx}, value=${tx.vout[idx].value} sats`);
    } catch (e: any) {
      setMessage(e?.message || String(e));
    }
  }, [fundingTxid, p2wshAddress]);

  const buildAndBroadcastSpend = useCallback(async () => {
    try {
      setBuilding(true);
      setBroadcasting(false);
      setMessage("");
      if (wscriptLen === 0 || !wscriptHex) throw new Error("witnessScript missing");
      if (!fundingTxid || fundingVout === "" || fundingValue === "") throw new Error("Missing funding outpoint or value");
      if (!recipient) throw new Error("Recipient address required");
      const value = Number(fundingValue);
      const fee = Number(sendFee);
      if (fee <= 0 || fee >= value) throw new Error("Fee must be >0 and < input value");

      const wscript = Buffer.from(wscriptHex, "hex");
      const p2wsh = bitcoin.payments.p2wsh({ redeem: { output: wscript }, network: TESTNET });
      const lockingScript = p2wsh.output!; // scriptPubKey of the UTXO we're spending

      const psbt = new bitcoin.Psbt({ network: TESTNET });
      psbt.addInput({
        hash: fundingTxid,
        index: Number(fundingVout),
        witnessUtxo: {
          script: lockingScript,
          value: value,
        },
      });
      psbt.addOutput({ address: recipient, value: value - fee });

      // Finalize the P2WSH input: witness stack is just [witnessScript]; script succeeds via OP_TRUE.
      const finalWitness = witnessStackToScriptWitness([wscript]);
      psbt.finalizeInput(0, () => ({ finalScriptWitness: finalWitness }));

      const rawtx = psbt.extractTransaction().toHex();

      setBuilding(false);
      setBroadcasting(true);
      // @ts-ignore
      const unisat = (window as any).unisat;
      const txid = await unisat.pushTx({ rawtx });
      setSpendTxid(txid);
      setBroadcasting(false);
      setMessage("Spend broadcasted.");
    } catch (e: any) {
      setBuilding(false);
      setBroadcasting(false);
      setMessage(e?.message || String(e));
    }
  }, [wscriptHex, wscriptLen, fundingTxid, fundingVout, fundingValue, recipient, sendFee]);

  const canFund = connected && !!p2wshAddress && wscriptLen > 0;
  const canSpend = !!fundingTxid && fundingVout !== "" && fundingValue !== "" && !!recipient;

  return (
    <div className="min-h-screen bg-slate-950 text-slate-100 p-6">
      <div className="max-w-3xl mx-auto space-y-6">
        <header className="flex items-center justify-between">
          <h1 className="text-2xl font-bold">SegWit P2WSH Data MVP (Testnet + UniSat)</h1>
          <button
            onClick={connect}
            className="px-3 py-2 rounded-xl bg-indigo-600 hover:bg-indigo-500 disabled:opacity-50"
          >
            {connected ? `Connected: ${address.slice(0, 6)}…${address.slice(-6)}` : "Connect UniSat (testnet)"}
          </button>
        </header>

        <section className="bg-slate-900/60 p-4 rounded-2xl shadow">
          <h2 className="font-semibold mb-3">1) Enter data → build P2WSH witnessScript</h2>
          <div className="flex gap-3 mb-3">
            <label className="flex items-center gap-2">
              <input type="radio" checked={mode === "utf8"} onChange={() => setMode("utf8")} />
              <span>UTF‑8</span>
            </label>
            <label className="flex items-center gap-2">
              <input type="radio" checked={mode === "hex"} onChange={() => setMode("hex")} />
              <span>Hex</span>
            </label>
          </div>
          <textarea
            className="w-full min-h-[100px] rounded-xl p-3 text-slate-900"
            value={dataInput}
            onChange={(e) => setDataInput(e.target.value)}
            placeholder={mode === "utf8" ? "Type some text…" : "deadbeef…"}
          />
          <div className="mt-3 grid grid-cols-1 md:grid-cols-2 gap-3 text-sm">
            <div className="space-y-2">
              <div className="bg-slate-800/70 rounded-xl p-3">
                <div className="opacity-70">Witness script size</div>
                <div className={`${wscriptLen > 3600 ? "text-red-400" : ""}`}>{wscriptLen} bytes</div>
              </div>
              <div className="bg-slate-800/70 rounded-xl p-3 break-all">
                <div className="opacity-70">P2WSH address (testnet)</div>
                <div>{p2wshAddress || "—"}</div>
              </div>
            </div>
            <div className="space-y-2">
              <div className="bg-slate-800/70 rounded-xl p-3 break-all">
                <div className="opacity-70">witnessScript (hex)</div>
                <div className="text-xs">{wscriptHex || "—"}</div>
              </div>
              <div className="bg-slate-800/70 rounded-xl p-3 break-all">
                <div className="opacity-70">scriptPubKey for UTXO (hex)</div>
                <div className="text-xs">{p2wshScriptPubKeyHex || "—"}</div>
              </div>
            </div>
          </div>
        </section>

        <section className="bg-slate-900/60 p-4 rounded-2xl shadow">
          <h2 className="font-semibold mb-3">2) Fund the P2WSH output (testnet)</h2>
          <div className="grid grid-cols-1 md:grid-cols-3 gap-3 items-end">
            <label className="block">
              <div className="text-sm opacity-80 mb-1">Amount (sats)</div>
              <input
                type="number"
                className="w-full rounded-xl p-2 text-slate-900"
                value={fundAmount}
                onChange={(e) => setFundAmount(Number(e.target.value))}
                min={400}
              />
            </label>
            <label className="block">
              <div className="text-sm opacity-80 mb-1">Fee rate (sats/vB)</div>
              <input
                type="number"
                className="w-full rounded-xl p-2 text-slate-900"
                value={feeRateFund}
                onChange={(e) => setFeeRateFund(Number(e.target.value))}
                min={1}
              />
            </label>
            <button
              onClick={fundP2WSH}
              disabled={!canFund}
              className="px-3 py-2 rounded-xl bg-emerald-600 hover:bg-emerald-500 disabled:opacity-50"
            >
              Fund to P2WSH
            </button>
          </div>
          <div className="mt-3 text-sm">
            {fundingTxid ? (
              <div>
                Funding txid: <a className="text-indigo-400 underline" target="_blank" rel="noreferrer" href={`https://mempool.space/testnet/tx/${fundingTxid}`}>{fundingTxid}</a>
              </div>
            ) : (
              <div className="opacity-70">This uses UniSat.sendBitcoin() from your wallet to the P2WSH address.</div>
            )}
          </div>
        </section>

        <section className="bg-slate-900/60 p-4 rounded-2xl shadow">
          <h2 className="font-semibold mb-3">3) Spend the P2WSH UTXO → reveal data (no sig needed)</h2>
          <div className="grid grid-cols-1 md:grid-cols-3 gap-3 items-end">
            <label className="block">
              <div className="text-sm opacity-80 mb-1">Funding txid</div>
              <input
                className="w-full rounded-xl p-2 text-slate-900"
                value={fundingTxid}
                onChange={(e) => setFundingTxid(e.target.value.trim())}
                placeholder="txid from step 2"
              />
            </label>
            <label className="block">
              <div className="text-sm opacity-80 mb-1">vout</div>
              <input
                type="number"
                className="w-full rounded-xl p-2 text-slate-900"
                value={fundingVout as any}
                onChange={(e) => setFundingVout(Number(e.target.value))}
                placeholder="index"
              />
            </label>
            <button onClick={autodetectVout} className="px-3 py-2 rounded-xl bg-sky-600 hover:bg-sky-500">Auto‑detect vout</button>
          </div>
          <div className="grid grid-cols-1 md:grid-cols-3 gap-3 items-end mt-3">
            <label className="block">
              <div className="text-sm opacity-80 mb-1">UTXO value (sats)</div>
              <input
                type="number"
                className="w-full rounded-xl p-2 text-slate-900"
                value={fundingValue as any}
                onChange={(e) => setFundingValue(Number(e.target.value))}
                placeholder="amount sent"
              />
            </label>
            <label className="block">
              <div className="text-sm opacity-80 mb-1">Recipient address</div>
              <input
                className="w-full rounded-xl p-2 text-slate-900"
                value={recipient}
                onChange={(e) => setRecipient(e.target.value.trim())}
                placeholder="tb1... (testnet)"
              />
            </label>
            <label className="block">
              <div className="text-sm opacity-80 mb-1">Fee (sats, flat)</div>
              <input
                type="number"
                className="w-full rounded-xl p-2 text-slate-900"
                value={sendFee}
                onChange={(e) => setSendFee(Number(e.target.value))}
                min={200}
              />
            </label>
          </div>
          <div className="mt-3 flex gap-3">
            <button
              onClick={buildAndBroadcastSpend}
              disabled={!canSpend || building || broadcasting}
              className="px-3 py-2 rounded-xl bg-amber-600 hover:bg-amber-500 disabled:opacity-50"
            >
              Build + Broadcast spend
            </button>
            {spendTxid && (
              <a className="px-3 py-2 rounded-xl bg-slate-800 hover:bg-slate-700" target="_blank" rel="noreferrer" href={`https://mempool.space/testnet/tx/${spendTxid}`}>View spend → {spendTxid.slice(0,10)}…</a>
            )}
          </div>
        </section>

        <section className="bg-slate-900/60 p-4 rounded-2xl shadow text-sm space-y-2">
          <h3 className="font-semibold">Notes</h3>
          <ul className="list-disc ml-5 space-y-1">
            <li>Policy: witnessScript ≤ ~3,600 bytes for broad relay. Consensus max is 10,000 bytes, but larger may be nonstandard.</li>
            <li>Your data lives in the <em>witnessScript</em> under an unexecuted branch. Spending reveals it; no signatures needed for that input.</li>
            <li>Funding uses <code>unisat.sendBitcoin()</code>. Spending broadcasts with <code>unisat.pushTx()</code>.</li>
            <li>Everything here runs on <strong>testnet</strong>. Use small amounts (≥~400 sats to avoid dust).</li>
          </ul>
          <div className="opacity-70">
            Tip: To chunk bigger payloads, create multiple P2WSH outputs (repeat Step 2) and add each as an input in one spend.
          </div>
        </section>

        {message && (
          <div className="p-3 rounded-xl bg-slate-800/80 border border-slate-700 text-sm">{message}</div>
        )}
      </div>
    </div>
  );
}

